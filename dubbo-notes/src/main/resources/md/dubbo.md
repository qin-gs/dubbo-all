### Dubbo



#### 简介

Apache Dubbo 是一款微服务开发框架，它提供了 RPC通信 与 微服务治理 两大关键能力。这意味着，使用 Dubbo 开发的微服务，将具备相互之间的远程发现与通信能力， 同时利用 Dubbo 提供的丰富服务治理能力，可以实现诸如服务发现、负载均衡、流量调度等服务治理诉求。

- 服务发现
- 流式通信
- 负载均衡
- 流量治理



#### 概念 架构

- 服务发现

  消费端自动发现服务地址列表的能力，借助于自动化的服务发现，微服务之间可以在无需感知对端部署位置与 IP 地址的情况下实现通信。

  Dubbo 提供的是一种 Client-Based 的服务发现机制，通常还需要部署额外的第三方注册中心组件来协调服务发现过程，如常用的 Nacos、Consul、Zookeeper 等

  <img src="./img/基本工作原理.png" alt="基本工作原理" style="zoom:50%;" />

  服务发现的一个核心组件是注册中心，Provider 注册地址到注册中心，Consumer 从注册中心读取和订阅 Provider 地址列表。 

- 协议

  协议是 RPC 的核心，它规范了数据在网络中的传输内容和格式。除必须的请求、响应数据外，通常还会包含额外控制数据，如单次请求的序列化方式、超时时间、压缩方式和鉴权信息等。

  - 数据交换格式：序列化方式
  - 协议结构：字段列表，字段语义，字段的排列方式
  - 协议通过定义规则，格式，语义来约定数据如何在网络中传输

  Triple

  dubbo2

- 流量管理

  流量管理的本质是将请求根据制定好的路由规则分发到应用服务上

- 配置

  - 启动阶段配置项：启动时读取的配置项，用于初始化各个组件，不会监听这些配置项的变化

  - 服务治理规则：服务治理规则主要作用是改变运行时服务的行为和选址逻辑，达到限流，权重配置等目的，包括覆盖规则、标签路由、条件路由。

  - 动态配置项：用于控制动态开关，Dubbo启动后监听动态配置项，当配置发生变化时，会自动进行相应的处理

- 部署架构

  - 注册中心

  - 配置中心

  - 元数据中心

    <img src="./img/Dubbo微服务组件与各个中心的交互过程.png" alt="Dubbo微服务组件与各个中心的交互过程" style="zoom: 67%;" />

- 扩展性

  在现有的架构或设计基础上，当未来某些方面发生变化的时候，我们能够以最小的改动来适应这种变化

  可扩展性的优点主要表现模块之间解耦，它符合开闭原则，对扩展开放，对修改关闭



#### 介绍与简介

- 路由规则
  - 动态路由
  - 权重路由
- 服务发现
- 动态配置



#### 高级操作

- 启动时检查

  Dubbo 缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止 Spring 初始化完成，以便上线时，能及早发现问题，默认 `check="true"`。

  可以关闭 某个服务的启动时检查，所有服务的启动时检查(没有提供者时报错)，注册中心的启动时检查(注册订阅失败时报错)

- 序列化协议安全

- 集群容错

  ![dubbo各节点关系](./img/dubbo各节点关系.jpg)

  - 这里的 `Invoker` 是 `Provider` 的一个可调用 `Service` 的抽象，`Invoker` 封装了 `Provider` 地址及 `Service` 接口信息
  - `Directory` 代表多个 `Invoker`，可以把它看成 `List<Invoker>` ，但与 `List` 不同的是，它的值可能是动态变化的，比如注册中心推送变更
  - `Cluster` 将 `Directory` 中的多个 `Invoker` 伪装成一个 `Invoker`，对上层透明，伪装过程包含了容错逻辑，调用失败后，重试另一个
  - `Router` 负责从多个 `Invoker` 中按路由规则选出子集，比如读写分离，应用隔离等
  - `LoadBalance` 负责从多个 `Invoker` 中选出具体的一个用于本次调用，选的过程包含了负载均衡算法，调用失败后，需要重选

  

  集群调用失败时，提供容错方案

  - failover(默认)：失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 `retries="2"` 来设置重试次数
  - failfast：快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录
  - failsafe：失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作
  - failback：失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作
  - forking：并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 `forks="2"` 来设置最大并行数
  - boardcast：广播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息

- 负载均衡

  Dubbo 提供的是客户端负载均衡，即由 Consumer 通过负载均衡算法得出需要将请求提交到哪个 Provider 实例

  - Random(默认)：加权随机 (慢的提供者累积请求的问题)

  - RoundRobin：加权轮询 (慢的提供者累积请求的问题)

  - LeastActive：加权最少活跃调用优先 (能者多劳)

  - ShortestResponse：加权最短相应优先 (关注相应速度，流量过于集中于高性能节点的问题)

  - ConsistentHash：一致性hash

  

- 线程模型

  如果事件处理的逻辑能迅速完成，并且不会发起新的 IO 请求，比如只是在内存中记个标识，则直接在 IO 线程上处理更快，因为减少了线程池调度。

  但如果事件处理逻辑较慢，或者需要发起新的 IO 请求，比如需要查询数据库，则必须派发到线程池，否则 IO 线程阻塞，将导致不能接收其它请求。

  如果用 IO 线程处理事件，又在事件处理过程中发起新的 IO 请求，比如在连接事件中发起登录请求，会报“可能引发死锁”异常，但不会真死锁。

  

  Dispatcher：

  ​	事件包括：请求，响应，连接事件，断开事件，心跳

  - all：所有消息都到线程池
  - direct：所有消息全部在io线程上执行
  - message：只有请求响应消息派发到线程池，其他连接在io线程上执行
  - execution：只有请求消息派发到线程池，其他连接在io线程上执行
  - connection：在 IO 线程上，将连接断开事件放入队列，有序逐个执行，其它消息派发到线程池

  

  ThreadPool：

  - fixed(默认)：固定大小线程池，启动时创建，不关闭
  - cached：缓存线程池，空闲一分钟自动删除，需要时重建
  - limited：可伸缩线程池(线程数只增长不收缩(避免收缩时突然来了大流量引起性能问题))
  - eager：优先创建 Worker 线程池



- 直连提供者

  在开发及测试环境下，经常需要绕过注册中心，只测试指定服务提供者，这时候可能需要点对点直连

  ```xml
  <dubbo:reference id="xxxService" interface="com.alibaba.xxx.XxxService" url="dubbo://localhost:20890" />
  ```

- 只订阅

  为方便开发测试，经常会在线下共用一个所有服务可用的注册中心，这时，如果一个正在开发中的服务提供者注册，可能会影响消费者不能正常运行。

  可以让服务提供者开发方，只订阅服务(开发的服务可能依赖其它服务)，而不注册正在开发的服务，通过直连测试正在开发的服务。

  ```xml
  <dubbo:registry address="10.20.153.10:9090" register="false" />
  ```

- 多协议

  不同服务在性能上适用不同协议进行传输，比如大数据用短连接协议，小数据大并发用长连接协议

  ```xml
  <!-- 多协议配置 -->
  <dubbo:protocol name="dubbo" port="20880" />
  <dubbo:protocol name="rmi" port="1099" />
  <!-- 使用dubbo协议暴露服务 -->
  <dubbo:service interface="com.alibaba.hello.api.HelloService" version="1.0.0" ref="helloService" protocol="dubbo" />
  <!-- 使用rmi协议暴露服务 -->
  <dubbo:service interface="com.alibaba.hello.api.DemoService" version="1.0.0" ref="demoService" protocol="rmi" /> 
  ```

- 多注册中心

  Dubbo 支持同一服务向多注册中心同时注册，或者不同服务分别注册到不同的注册中心上去，甚至可以同时引用注册在不同注册中心上的同名服务

- 服务分组

  当一个接口有多种实现时，可以用 group 区分

  ```xml
  <dubbo:service group="feedback" interface="com.xxx.IndexService" />
  <dubbo:service group="member" interface="com.xxx.IndexService" />
  ```

- 静态服务

  有时候希望人工管理服务提供者的上线和下线，此时需将注册中心标识为非动态管理模式。

- 多版本

  当一个接口实现，出现不兼容升级时，可以用版本号过渡，版本号不同的服务相互间不引用。

- 分组聚合

  通过分组对结果进行聚合并返回聚合后的结果，比如菜单服务，用group区分同一接口的多种实现，现在消费方需从每种group中调用一次并返回结果，对结果进行合并之后返回，这样就可以实现聚合菜单项。

- 参数验证

  
